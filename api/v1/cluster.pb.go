// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cluster.proto

package coolbeans_api_v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type JoinRequest struct {
	// Node ID of the node interested in joining
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Address of the replica interested in joining
	Addr                 string   `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JoinRequest) Reset()         { *m = JoinRequest{} }
func (m *JoinRequest) String() string { return proto.CompactTextString(m) }
func (*JoinRequest) ProtoMessage()    {}
func (*JoinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cfb3b8ec240c376, []int{0}
}

func (m *JoinRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JoinRequest.Unmarshal(m, b)
}
func (m *JoinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JoinRequest.Marshal(b, m, deterministic)
}
func (m *JoinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinRequest.Merge(m, src)
}
func (m *JoinRequest) XXX_Size() int {
	return xxx_messageInfo_JoinRequest.Size(m)
}
func (m *JoinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JoinRequest proto.InternalMessageInfo

func (m *JoinRequest) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *JoinRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type LeaderInfoResponse struct {
	// Node ID of the leader
	LeaderNodeId string `protobuf:"bytes,1,opt,name=leader_node_id,json=leaderNodeId,proto3" json:"leader_node_id,omitempty"`
	// Address of the leader
	LeaderAddr           string   `protobuf:"bytes,2,opt,name=leader_addr,json=leaderAddr,proto3" json:"leader_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LeaderInfoResponse) Reset()         { *m = LeaderInfoResponse{} }
func (m *LeaderInfoResponse) String() string { return proto.CompactTextString(m) }
func (*LeaderInfoResponse) ProtoMessage()    {}
func (*LeaderInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3cfb3b8ec240c376, []int{1}
}

func (m *LeaderInfoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LeaderInfoResponse.Unmarshal(m, b)
}
func (m *LeaderInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LeaderInfoResponse.Marshal(b, m, deterministic)
}
func (m *LeaderInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaderInfoResponse.Merge(m, src)
}
func (m *LeaderInfoResponse) XXX_Size() int {
	return xxx_messageInfo_LeaderInfoResponse.Size(m)
}
func (m *LeaderInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaderInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LeaderInfoResponse proto.InternalMessageInfo

func (m *LeaderInfoResponse) GetLeaderNodeId() string {
	if m != nil {
		return m.LeaderNodeId
	}
	return ""
}

func (m *LeaderInfoResponse) GetLeaderAddr() string {
	if m != nil {
		return m.LeaderAddr
	}
	return ""
}

func init() {
	proto.RegisterType((*JoinRequest)(nil), "coolbeans.api.v1.JoinRequest")
	proto.RegisterType((*LeaderInfoResponse)(nil), "coolbeans.api.v1.LeaderInfoResponse")
}

func init() {
	proto.RegisterFile("cluster.proto", fileDescriptor_3cfb3b8ec240c376)
}

var fileDescriptor_3cfb3b8ec240c376 = []byte{
	// 243 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4d, 0xce, 0x29, 0x2d,
	0x2e, 0x49, 0x2d, 0xd2, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x48, 0xce, 0xcf, 0xcf, 0x49,
	0x4a, 0x4d, 0xcc, 0x2b, 0xd6, 0x4b, 0x2c, 0xc8, 0xd4, 0x2b, 0x33, 0x94, 0xe2, 0x4e, 0xcd, 0x2d,
	0x28, 0xa9, 0x84, 0x48, 0x2b, 0x59, 0x71, 0x71, 0x7b, 0xe5, 0x67, 0xe6, 0x05, 0xa5, 0x16, 0x96,
	0xa6, 0x16, 0x97, 0x08, 0x89, 0x73, 0xb1, 0xe7, 0xe5, 0xa7, 0xa4, 0xc6, 0x67, 0xa6, 0x48, 0x30,
	0x2a, 0x30, 0x6a, 0x70, 0x06, 0xb1, 0x81, 0xb8, 0x9e, 0x29, 0x42, 0x42, 0x5c, 0x2c, 0x89, 0x29,
	0x29, 0x45, 0x12, 0x4c, 0x60, 0x51, 0x30, 0x5b, 0x29, 0x9a, 0x4b, 0xc8, 0x27, 0x35, 0x31, 0x25,
	0xb5, 0xc8, 0x33, 0x2f, 0x2d, 0x3f, 0x28, 0xb5, 0xb8, 0x20, 0x3f, 0xaf, 0x38, 0x55, 0x48, 0x85,
	0x8b, 0x2f, 0x07, 0x2c, 0x1a, 0x8f, 0x6a, 0x12, 0x0f, 0x44, 0xd4, 0x0f, 0x62, 0x9e, 0x3c, 0x17,
	0x37, 0x54, 0x15, 0x92, 0xb1, 0x5c, 0x10, 0x21, 0xc7, 0x94, 0x94, 0x22, 0xa3, 0x77, 0x8c, 0x5c,
	0xec, 0xce, 0x10, 0x9f, 0x08, 0x39, 0x70, 0xb1, 0x80, 0x1c, 0x29, 0x24, 0xab, 0x87, 0xee, 0x19,
	0x3d, 0x24, 0xc7, 0x4b, 0x89, 0x63, 0x4a, 0xbb, 0x82, 0xbc, 0xaa, 0xc4, 0x20, 0xe4, 0xcb, 0xc5,
	0x85, 0x70, 0xaa, 0x10, 0x2e, 0x85, 0x52, 0x2a, 0x98, 0x12, 0x98, 0x3e, 0x54, 0x62, 0x10, 0x0a,
	0xe2, 0xe2, 0x85, 0x88, 0x87, 0x16, 0xa4, 0x24, 0x96, 0xa4, 0x16, 0x53, 0x6c, 0xa2, 0x01, 0x63,
	0x12, 0x1b, 0x38, 0x42, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x4e, 0xbc, 0x70, 0xc0,
	0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ClusterClient is the client API for Cluster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterClient interface {
	// Request to join this cluster
	Join(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*Empty, error)
	// Query the cluster for the current leader info
	LeaderInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LeaderInfoResponse, error)
	// Returns updates to any leader changes
	LeaderUpdates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Cluster_LeaderUpdatesClient, error)
}

type clusterClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterClient(cc grpc.ClientConnInterface) ClusterClient {
	return &clusterClient{cc}
}

func (c *clusterClient) Join(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/coolbeans.api.v1.Cluster/Join", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) LeaderInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LeaderInfoResponse, error) {
	out := new(LeaderInfoResponse)
	err := c.cc.Invoke(ctx, "/coolbeans.api.v1.Cluster/LeaderInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) LeaderUpdates(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Cluster_LeaderUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Cluster_serviceDesc.Streams[0], "/coolbeans.api.v1.Cluster/LeaderUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &clusterLeaderUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Cluster_LeaderUpdatesClient interface {
	Recv() (*LeaderInfoResponse, error)
	grpc.ClientStream
}

type clusterLeaderUpdatesClient struct {
	grpc.ClientStream
}

func (x *clusterLeaderUpdatesClient) Recv() (*LeaderInfoResponse, error) {
	m := new(LeaderInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ClusterServer is the server API for Cluster service.
type ClusterServer interface {
	// Request to join this cluster
	Join(context.Context, *JoinRequest) (*Empty, error)
	// Query the cluster for the current leader info
	LeaderInfo(context.Context, *Empty) (*LeaderInfoResponse, error)
	// Returns updates to any leader changes
	LeaderUpdates(*Empty, Cluster_LeaderUpdatesServer) error
}

// UnimplementedClusterServer can be embedded to have forward compatible implementations.
type UnimplementedClusterServer struct {
}

func (*UnimplementedClusterServer) Join(ctx context.Context, req *JoinRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Join not implemented")
}
func (*UnimplementedClusterServer) LeaderInfo(ctx context.Context, req *Empty) (*LeaderInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaderInfo not implemented")
}
func (*UnimplementedClusterServer) LeaderUpdates(req *Empty, srv Cluster_LeaderUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method LeaderUpdates not implemented")
}

func RegisterClusterServer(s *grpc.Server, srv ClusterServer) {
	s.RegisterService(&_Cluster_serviceDesc, srv)
}

func _Cluster_Join_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).Join(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coolbeans.api.v1.Cluster/Join",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).Join(ctx, req.(*JoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_LeaderInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).LeaderInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/coolbeans.api.v1.Cluster/LeaderInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).LeaderInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_LeaderUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ClusterServer).LeaderUpdates(m, &clusterLeaderUpdatesServer{stream})
}

type Cluster_LeaderUpdatesServer interface {
	Send(*LeaderInfoResponse) error
	grpc.ServerStream
}

type clusterLeaderUpdatesServer struct {
	grpc.ServerStream
}

func (x *clusterLeaderUpdatesServer) Send(m *LeaderInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Cluster_serviceDesc = grpc.ServiceDesc{
	ServiceName: "coolbeans.api.v1.Cluster",
	HandlerType: (*ClusterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Join",
			Handler:    _Cluster_Join_Handler,
		},
		{
			MethodName: "LeaderInfo",
			Handler:    _Cluster_LeaderInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LeaderUpdates",
			Handler:       _Cluster_LeaderUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cluster.proto",
}
